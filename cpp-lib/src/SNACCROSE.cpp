//   NOTE: this is a machine generated file--editing not recommended
//
// SNACCROSE.cpp - class member functions for ASN.1 module SNACC-ROSE
//
//   This file was generated by esnacc
//   esnacc by Jan Fellner - estos GmbH


#include "SNACCROSE.h"

namespace SNACC{
//------------------------------------------------------------------------------
// class member definitions:

ROSERejectChoice::ROSERejectChoice(const ROSERejectChoice &that)
{
   Init();
   *this = that;
}
void ROSERejectChoice::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = invokedIDCid;
  invokedID = NULL;
}


int ROSERejectChoice::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (invokedID != NULL)
		invokedID->checkConstraints(pConstraintFails);

	if (invokednull != NULL)
		invokednull->checkConstraints(pConstraintFails);

	return 0;
}


void ROSERejectChoice::Clear()
{
  switch (choiceId)
  {
    case invokedIDCid:
      delete invokedID;
      invokedID = NULL;
      break;
    case invokednullCid:
      delete invokednull;
      invokednull = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *ROSERejectChoice::Clone() const
{
  return new ROSERejectChoice(*this);
}

ROSERejectChoice &ROSERejectChoice::operator = (const ROSERejectChoice &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.invokedID != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case invokedIDCid:
           invokedID = new AsnInt(*that.invokedID);
           break;
         case invokednullCid:
           invokednull = new AsnNull(*that.invokednull);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
ROSERejectChoice::BEncContent (AsnBuf &_b) const
{
    FUNC("ROSERejectChoice::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case invokedIDCid:
      l = invokedID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
      break;

    case invokednullCid:
      l = invokednull->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, NULLTYPE_TAG_CODE);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // ROSERejectChoice::BEncContent


void ROSERejectChoice::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("ROSERejectChoice::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
      choiceId = invokedIDCid;
        invokedID = new AsnInt;
        invokedID->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE):
      choiceId = invokednullCid;
        invokednull = new AsnNull;
        invokednull->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // ROSERejectChoice::BDecContent


AsnLen ROSERejectChoice::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void ROSERejectChoice::JEnc (EJson::Value &b) const
{
   FUNC("ROSERejectChoice::JEnc()");
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  switch (choiceId)
  {
    case invokedIDCid:
    invokedID->JEnc (tmp);
    b["invokedID"] = tmp;
      break;

    case invokednullCid:
    invokednull->JEnc (tmp);
    b["invokednull"] = tmp;
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
} // ROSERejectChoice::JEnc


void ROSERejectChoice::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

bool ROSERejectChoice::JDec (const EJson::Value &b){
   FUNC("ROSERejectChoice::JDec()");
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("invokedID")) {
    choiceId = invokedIDCid;
    delete invokedID;
    invokedID = new AsnInt;
    if (!invokedID->JDec(b["invokedID"])) throw InvalidTagException(typeName(), "decode failed: invokedID", STACK_ENTRY);
  }
  else if (b.isMember("invokednull")) {
    choiceId = invokednullCid;
    delete invokednull;
    invokednull = new AsnNull;
    if (!invokednull->JDec(b["invokednull"])) throw InvalidTagException(typeName(), "decode failed: invokednull", STACK_ENTRY);
  }
  else
     throw InvalidTagException(typeName(), "no valid choice member", STACK_ENTRY);
  return true;
} // ROSERejectChoice::JDec


void ROSERejectChoice::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case invokedIDCid:
		os << "invokedID ";
		if (invokedID)
			invokedID->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case invokednullCid:
		os << "invokednull ";
		if (invokednull)
			invokednull->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of ROSERejectChoice::Print()

void ROSERejectChoice::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"ROSERejectChoice\" type=\"CHOICE\">";
  }
  else
        os << "<ROSERejectChoice type=\"CHOICE\">";
  switch (choiceId)
  {
    case invokedIDCid:
      if (invokedID)
        invokedID->PrintXML(os,"invokedID");
      else
      {
        os << "<invokedID -- void3 -- /invokedID>" << std::endl;
      }
      break;

    case invokednullCid:
      if (invokednull)
        invokednull->PrintXML(os,"invokednull");
      else
      {
        os << "<invokednull -- void3 -- /invokednull>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</ROSERejectChoice>";
} // ROSERejectChoice::PrintXML

void ROSEResultSeq::Init(void)
{
}


int ROSEResultSeq::checkConstraints(ConstraintFailList* pConstraintFails) const{
	resultValue.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void ROSEResultSeq::Clear()
{
}

ROSEResultSeq::ROSEResultSeq(const ROSEResultSeq &that)
{
   Init();
   *this = that;
}
AsnType *ROSEResultSeq::Clone() const
{
  return new ROSEResultSeq(*this);
}

ROSEResultSeq &ROSEResultSeq::operator = (const ROSEResultSeq &that)
{
  if (this != &that)
  {
    Clear();
    resultValue = that.resultValue;
    result = that.result;
  }

  return *this;
}

AsnLen
ROSEResultSeq::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEnc (_b);
    totalLen += l;

    l = resultValue.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ROSEResultSeq::BEncContent


void ROSEResultSeq::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEResultSeq::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resultValue.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  // ANY type
  result.BDec (_b, seqBytesDecoded);


  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEResultSeq::BDecContent

AsnLen ROSEResultSeq::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEResultSeq::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

    resultValue.JEnc (tmp);
    b["resultValue"] = tmp;

    result.JEnc (tmp);
    b["result"] = tmp;

}


void ROSEResultSeq::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEResultSeq::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEResultSeq::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("resultValue")) {
    if (!resultValue.JDec(b["resultValue"])) throw InvalidTagException(typeName(), "decode failed: resultValue", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: resultValue", STACK_ENTRY);
  if (b.isMember("result")) {
    if (!result.JDec(b["result"])) throw InvalidTagException(typeName(), "decode failed: result", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: result", STACK_ENTRY);
  return true;
} // ROSEResultSeq::JDec

void ROSEResultSeq::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	Indent(os, indent);
	os << "resultValue ";
	resultValue.Print(os, indent);
	os << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);
	os << std::endl;

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEResultSeq::Print()

void ROSEResultSeq::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    resultValue.PrintXML(os, "resultValue");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEResultSeq::PrintXML


void ROSEAuth::Init(void)
{
}


int ROSEAuth::checkConstraints(ConstraintFailList* pConstraintFails) const{
	method.checkConstraints(pConstraintFails);

	authdata.checkConstraints(pConstraintFails);

	return 0;
}


void ROSEAuth::Clear()
{
}

ROSEAuth::ROSEAuth(const ROSEAuth &that)
{
   Init();
   *this = that;
}
AsnType *ROSEAuth::Clone() const
{
  return new ROSEAuth(*this);
}

ROSEAuth &ROSEAuth::operator = (const ROSEAuth &that)
{
  if (this != &that)
  {
    Clear();
    method = that.method;
    authdata = that.authdata;
  }

  return *this;
}

AsnLen
ROSEAuth::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = authdata.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = method.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ROSEAuth::BEncContent


void ROSEAuth::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEAuth::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    method.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    authdata.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEAuth::BDecContent

AsnLen ROSEAuth::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEAuth::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

    method.JEnc (tmp);
    b["method"] = tmp;

    authdata.JEnc (tmp);
    b["authdata"] = tmp;

}


void ROSEAuth::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEAuth::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEAuth::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("method")) {
    if (!method.JDec(b["method"])) throw InvalidTagException(typeName(), "decode failed: method", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: method", STACK_ENTRY);
  if (b.isMember("authdata")) {
    if (!authdata.JDec(b["authdata"])) throw InvalidTagException(typeName(), "decode failed: authdata", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: authdata", STACK_ENTRY);
  return true;
} // ROSEAuth::JDec

void ROSEAuth::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	Indent(os, indent);
	os << "method ";
	method.Print(os, indent);
	os << std::endl;

	Indent(os, indent);
	os << "authdata ";
	authdata.Print(os, indent);
	os << std::endl;

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEAuth::Print()

void ROSEAuth::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    method.PrintXML(os, "method");

    authdata.PrintXML(os, "authdata");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEAuth::PrintXML


void ROSEError::Init(void)
{
  sessionID = NULL;
  error = NULL;
}


int ROSEError::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (sessionID != NULL)
		sessionID->checkConstraints(pConstraintFails);

	invokedID.checkConstraints(pConstraintFails);

	error_value.checkConstraints(pConstraintFails);

	if (error != NULL)
		error->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEError::Clear()
{
  if(sessionID)
    delete sessionID;
  sessionID = NULL;
  if(error)
    delete error;
  error = NULL;
}

ROSEError::ROSEError(const ROSEError &that)
{
   Init();
   *this = that;
}
AsnType *ROSEError::Clone() const
{
  return new ROSEError(*this);
}

ROSEError &ROSEError::operator = (const ROSEError &that)
{
  if (this != &that)
  {
    Clear();
    if (that.sessionID)
    {
      if (!sessionID)
        sessionID = new UTF8String;
      *sessionID = *that.sessionID;
    }
    else
    {
      delete sessionID;
      sessionID = NULL;
    }
    invokedID = that.invokedID;
    error_value = that.error_value;
    if (that.error)
    {
      if (!error)
        error = new AsnAny;
      *error = *that.error;
    }
    else
    {
      delete error;
      error = NULL;
    }
  }

  return *this;
}

AsnLen
ROSEError::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (error))
  {
    l = error->BEnc (_b);
    totalLen += l;
  }

    l = error_value.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = invokedID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  if (NOT_NULL (sessionID))
  {
    l = sessionID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // ROSEError::BEncContent


void ROSEError::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEError::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 1))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
       && (tag1 != MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  sessionID = new UTF8String;
    sessionID->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    invokedID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    error_value.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = _b.PeekByte();

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDecEoc (_b, seqBytesDecoded);

        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  // ANY type
  error = new AsnAny;
  error->BDec (_b, seqBytesDecoded);


  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEError::BDecContent

AsnLen ROSEError::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEError::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  if (NOT_NULL (sessionID))
  {
    sessionID->JEnc (tmp);
    b["sessionID"] = tmp;
  }

    invokedID.JEnc (tmp);
    b["invokedID"] = tmp;

    error_value.JEnc (tmp);
    b["error_value"] = tmp;

  if (NOT_NULL (error))
  {
    error->JEnc (tmp);
    b["error"] = tmp;
  }

}


void ROSEError::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEError::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEError::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("sessionID")) {
     delete sessionID;
    sessionID = new UTF8String;
    if (!sessionID->JDec(b["sessionID"])) throw InvalidTagException(typeName(), "decode failed: sessionID", STACK_ENTRY);
  }
  if (b.isMember("invokedID")) {
    if (!invokedID.JDec(b["invokedID"])) throw InvalidTagException(typeName(), "decode failed: invokedID", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: invokedID", STACK_ENTRY);
  if (b.isMember("error_value")) {
    if (!error_value.JDec(b["error_value"])) throw InvalidTagException(typeName(), "decode failed: error_value", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: error_value", STACK_ENTRY);
  if (b.isMember("error")) {
     delete error;
    error = new AsnAny;
    if (!error->JDec(b["error"])) throw InvalidTagException(typeName(), "decode failed: error", STACK_ENTRY);
  }
  return true;
} // ROSEError::JDec

void ROSEError::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	if (NOT_NULL (sessionID))
	{
		Indent(os, indent);
		os << "sessionID ";
		sessionID->Print(os, indent);
		os << std::endl;
	}

	Indent(os, indent);
	os << "invokedID ";
	invokedID.Print(os, indent);
	os << std::endl;

	Indent(os, indent);
	os << "error-value ";
	error_value.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (error))
	{
		Indent(os, indent);
		os << "error ";
		error->Print(os, indent);
		os << std::endl;
	}

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEError::Print()

void ROSEError::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
  if (NOT_NULL (sessionID))
  {
    sessionID->PrintXML(os, "sessionID");
  }

    invokedID.PrintXML(os, "invokedID");

    error_value.PrintXML(os, "error-value");

  if (NOT_NULL (error))
  {
    error->PrintXML(os, "error");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEError::PrintXML


void ROSEAuthRequest::Init(void)
{
  context = NULL;
}


int ROSEAuthRequest::checkConstraints(ConstraintFailList* pConstraintFails) const{
	auth.checkConstraints(pConstraintFails);

	if (context != NULL)
		context->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEAuthRequest::Clear()
{
  auth.Clear();
  if(context)
    delete context;
  context = NULL;
}

ROSEAuthRequest::ROSEAuthRequest(const ROSEAuthRequest &that)
{
   Init();
   *this = that;
}
AsnType *ROSEAuthRequest::Clone() const
{
  return new ROSEAuthRequest(*this);
}

ROSEAuthRequest &ROSEAuthRequest::operator = (const ROSEAuthRequest &that)
{
  if (this != &that)
  {
    Clear();
    auth = that.auth;
    if (that.context)
    {
      if (!context)
        context = new UTF8String;
      *context = *that.context;
    }
    else
    {
      delete context;
      context = NULL;
    }
  }

  return *this;
}

AsnLen
ROSEAuthRequest::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (context))
  {
    l = context->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    totalLen += l;
  }

    l = auth.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ROSEAuthRequest::BEncContent


void ROSEAuthRequest::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEAuthRequest::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    auth.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  context = new UTF8String;
    context->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEAuthRequest::BDecContent

AsnLen ROSEAuthRequest::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEAuthRequest::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

    auth.JEnc (tmp);
    b["auth"] = tmp;

  if (NOT_NULL (context))
  {
    context->JEnc (tmp);
    b["context"] = tmp;
  }

}


void ROSEAuthRequest::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEAuthRequest::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEAuthRequest::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("auth")) {
    if (!auth.JDec(b["auth"])) throw InvalidTagException(typeName(), "decode failed: auth", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: auth", STACK_ENTRY);
  if (b.isMember("context")) {
     delete context;
    context = new UTF8String;
    if (!context->JDec(b["context"])) throw InvalidTagException(typeName(), "decode failed: context", STACK_ENTRY);
  }
  return true;
} // ROSEAuthRequest::JDec

void ROSEAuthRequest::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	Indent(os, indent);
	os << "auth ";
	auth.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (context))
	{
		Indent(os, indent);
		os << "context ";
		context->Print(os, indent);
		os << std::endl;
	}

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEAuthRequest::Print()

void ROSEAuthRequest::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    auth.PrintXML(os, "auth");

  if (NOT_NULL (context))
  {
    context->PrintXML(os, "context");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEAuthRequest::PrintXML


void ROSEAuthResult::Init(void)
{
  context = NULL;
}


int ROSEAuthResult::checkConstraints(ConstraintFailList* pConstraintFails) const{
	authList.checkConstraints(pConstraintFails);

	if (context != NULL)
		context->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEAuthResult::Clear()
{
  if(context)
    delete context;
  context = NULL;
}

ROSEAuthResult::ROSEAuthResult(const ROSEAuthResult &that)
{
   Init();
   *this = that;
}
AsnType *ROSEAuthResult::Clone() const
{
  return new ROSEAuthResult(*this);
}

ROSEAuthResult &ROSEAuthResult::operator = (const ROSEAuthResult &that)
{
  if (this != &that)
  {
    Clear();
    authList = that.authList;
    if (that.context)
    {
      if (!context)
        context = new UTF8String;
      *context = *that.context;
    }
    else
    {
      delete context;
      context = NULL;
    }
  }

  return *this;
}

AsnLen
ROSEAuthResult::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (context))
  {
    l = context->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    totalLen += l;
  }

    l = authList.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ROSEAuthResult::BEncContent


void ROSEAuthResult::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEAuthResult::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    authList.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  context = new UTF8String;
    context->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEAuthResult::BDecContent

AsnLen ROSEAuthResult::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEAuthResult::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

    authList.JEnc (tmp);
    b["authList"] = tmp;

  if (NOT_NULL (context))
  {
    context->JEnc (tmp);
    b["context"] = tmp;
  }

}


void ROSEAuthResult::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEAuthResult::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEAuthResult::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("authList")) {
    if (!authList.JDec(b["authList"])) throw InvalidTagException(typeName(), "decode failed: authList", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: authList", STACK_ENTRY);
  if (b.isMember("context")) {
     delete context;
    context = new UTF8String;
    if (!context->JDec(b["context"])) throw InvalidTagException(typeName(), "decode failed: context", STACK_ENTRY);
  }
  return true;
} // ROSEAuthResult::JDec

void ROSEAuthResult::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	Indent(os, indent);
	os << "authList ";
	authList.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (context))
	{
		Indent(os, indent);
		os << "context ";
		context->Print(os, indent);
		os << std::endl;
	}

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEAuthResult::Print()

void ROSEAuthResult::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    authList.PrintXML(os, "authList");

  if (NOT_NULL (context))
  {
    context->PrintXML(os, "context");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEAuthResult::PrintXML


void ROSEInvoke::Init(void)
{
  sessionID = NULL;
  linked_ID = NULL;
  operationName = NULL;
  authentication = NULL;
  argument = NULL;
}


int ROSEInvoke::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (sessionID != NULL)
		sessionID->checkConstraints(pConstraintFails);

	invokeID.checkConstraints(pConstraintFails);

	if (linked_ID != NULL)
		linked_ID->checkConstraints(pConstraintFails);

	if (operationName != NULL)
		operationName->checkConstraints(pConstraintFails);

	if (authentication != NULL)
		authentication->checkConstraints(pConstraintFails);

	operationID.checkConstraints(pConstraintFails);

	if (argument != NULL)
		argument->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEInvoke::Clear()
{
  if(sessionID)
    delete sessionID;
  sessionID = NULL;
  if(linked_ID)
    delete linked_ID;
  linked_ID = NULL;
  if(operationName)
    delete operationName;
  operationName = NULL;
  if(authentication)
    delete authentication;
  authentication = NULL;
  if(argument)
    delete argument;
  argument = NULL;
}

ROSEInvoke::ROSEInvoke(const ROSEInvoke &that)
{
   Init();
   *this = that;
}
AsnType *ROSEInvoke::Clone() const
{
  return new ROSEInvoke(*this);
}

ROSEInvoke &ROSEInvoke::operator = (const ROSEInvoke &that)
{
  if (this != &that)
  {
    Clear();
    if (that.sessionID)
    {
      if (!sessionID)
        sessionID = new UTF8String;
      *sessionID = *that.sessionID;
    }
    else
    {
      delete sessionID;
      sessionID = NULL;
    }
    invokeID = that.invokeID;
    if (that.linked_ID)
    {
      if (!linked_ID)
        linked_ID = new AsnInt;
      *linked_ID = *that.linked_ID;
    }
    else
    {
      delete linked_ID;
      linked_ID = NULL;
    }
    if (that.operationName)
    {
      if (!operationName)
        operationName = new UTF8String;
      *operationName = *that.operationName;
    }
    else
    {
      delete operationName;
      operationName = NULL;
    }
    if (that.authentication)
    {
      if (!authentication)
        authentication = new ROSEAuthRequest;
      *authentication = *that.authentication;
    }
    else
    {
      delete authentication;
      authentication = NULL;
    }
    operationID = that.operationID;
    if (that.argument)
    {
      if (!argument)
        argument = new AsnAny;
      *argument = *that.argument;
    }
    else
    {
      delete argument;
      argument = NULL;
    }
  }

  return *this;
}

AsnLen
ROSEInvoke::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (argument))
  {
    l = argument->BEnc (_b);
    totalLen += l;
  }

    l = operationID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  if (NOT_NULL (authentication))
  {
    l = authentication->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;
  }

  if (NOT_NULL (operationName))
  {
    l = operationName->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (linked_ID))
  {
    l = linked_ID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;
  }

    l = invokeID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  if (NOT_NULL (sessionID))
  {
    l = sessionID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // ROSEInvoke::BEncContent


void ROSEInvoke::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEInvoke::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 1))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
       && (tag1 != MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  sessionID = new UTF8String;
    sessionID->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    invokeID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if (tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  linked_ID = new AsnInt;
    linked_ID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 2))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
       && (tag1 != MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  operationName = new UTF8String;
    operationName->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 3))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  authentication = new ROSEAuthRequest;
    authentication->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    operationID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = _b.PeekByte();

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDecEoc (_b, seqBytesDecoded);

        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  // ANY type
  argument = new AsnAny;
  argument->BDec (_b, seqBytesDecoded);


  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEInvoke::BDecContent

AsnLen ROSEInvoke::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEInvoke::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  if (NOT_NULL (sessionID))
  {
    sessionID->JEnc (tmp);
    b["sessionID"] = tmp;
  }

    invokeID.JEnc (tmp);
    b["invokeID"] = tmp;

  if (NOT_NULL (linked_ID))
  {
    linked_ID->JEnc (tmp);
    b["linked_ID"] = tmp;
  }

  if (NOT_NULL (operationName))
  {
    operationName->JEnc (tmp);
    b["operationName"] = tmp;
  }

  if (NOT_NULL (authentication))
  {
    authentication->JEnc (tmp);
    b["authentication"] = tmp;
  }

    operationID.JEnc (tmp);
    b["operationID"] = tmp;

  if (NOT_NULL (argument))
  {
    argument->JEnc (tmp);
    b["argument"] = tmp;
  }

}


void ROSEInvoke::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEInvoke::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEInvoke::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("sessionID")) {
     delete sessionID;
    sessionID = new UTF8String;
    if (!sessionID->JDec(b["sessionID"])) throw InvalidTagException(typeName(), "decode failed: sessionID", STACK_ENTRY);
  }
  if (b.isMember("invokeID")) {
    if (!invokeID.JDec(b["invokeID"])) throw InvalidTagException(typeName(), "decode failed: invokeID", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: invokeID", STACK_ENTRY);
  if (b.isMember("linked_ID")) {
     delete linked_ID;
    linked_ID = new AsnInt;
    if (!linked_ID->JDec(b["linked_ID"])) throw InvalidTagException(typeName(), "decode failed: linked_ID", STACK_ENTRY);
  }
  if (b.isMember("operationName")) {
     delete operationName;
    operationName = new UTF8String;
    if (!operationName->JDec(b["operationName"])) throw InvalidTagException(typeName(), "decode failed: operationName", STACK_ENTRY);
  }
  if (b.isMember("authentication")) {
     delete authentication;
    authentication = new ROSEAuthRequest;
    if (!authentication->JDec(b["authentication"])) throw InvalidTagException(typeName(), "decode failed: authentication", STACK_ENTRY);
  }
  if (b.isMember("operationID")) {
    if (!operationID.JDec(b["operationID"])) throw InvalidTagException(typeName(), "decode failed: operationID", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: operationID", STACK_ENTRY);
  if (b.isMember("argument")) {
     delete argument;
    argument = new AsnAny;
    if (!argument->JDec(b["argument"])) throw InvalidTagException(typeName(), "decode failed: argument", STACK_ENTRY);
  }
  return true;
} // ROSEInvoke::JDec

void ROSEInvoke::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	if (NOT_NULL (sessionID))
	{
		Indent(os, indent);
		os << "sessionID ";
		sessionID->Print(os, indent);
		os << std::endl;
	}

	Indent(os, indent);
	os << "invokeID ";
	invokeID.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (linked_ID))
	{
		Indent(os, indent);
		os << "linked-ID ";
		linked_ID->Print(os, indent);
		os << std::endl;
	}

	if (NOT_NULL (operationName))
	{
		Indent(os, indent);
		os << "operationName ";
		operationName->Print(os, indent);
		os << std::endl;
	}

	if (NOT_NULL (authentication))
	{
		Indent(os, indent);
		os << "authentication ";
		authentication->Print(os, indent);
		os << std::endl;
	}

	Indent(os, indent);
	os << "operationID ";
	operationID.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (argument))
	{
		Indent(os, indent);
		os << "argument ";
		argument->Print(os, indent);
		os << std::endl;
	}

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEInvoke::Print()

void ROSEInvoke::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
  if (NOT_NULL (sessionID))
  {
    sessionID->PrintXML(os, "sessionID");
  }

    invokeID.PrintXML(os, "invokeID");

  if (NOT_NULL (linked_ID))
  {
    linked_ID->PrintXML(os, "linked-ID");
  }

  if (NOT_NULL (operationName))
  {
    operationName->PrintXML(os, "operationName");
  }

  if (NOT_NULL (authentication))
  {
    authentication->PrintXML(os, "authentication");
  }

    operationID.PrintXML(os, "operationID");

  if (NOT_NULL (argument))
  {
    argument->PrintXML(os, "argument");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEInvoke::PrintXML


void ROSEResult::Init(void)
{
  sessionID = NULL;
  result = NULL;
}


int ROSEResult::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (sessionID != NULL)
		sessionID->checkConstraints(pConstraintFails);

	invokeID.checkConstraints(pConstraintFails);

	if (result != NULL)
		result->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEResult::Clear()
{
  if(sessionID)
    delete sessionID;
  sessionID = NULL;
  if(result)
    delete result;
  result = NULL;
}

ROSEResult::ROSEResult(const ROSEResult &that)
{
   Init();
   *this = that;
}
AsnType *ROSEResult::Clone() const
{
  return new ROSEResult(*this);
}

ROSEResult &ROSEResult::operator = (const ROSEResult &that)
{
  if (this != &that)
  {
    Clear();
    if (that.sessionID)
    {
      if (!sessionID)
        sessionID = new UTF8String;
      *sessionID = *that.sessionID;
    }
    else
    {
      delete sessionID;
      sessionID = NULL;
    }
    invokeID = that.invokeID;
    if (that.result)
    {
      if (!result)
        result = new ROSEResultSeq;
      *result = *that.result;
    }
    else
    {
      delete result;
      result = NULL;
    }
  }

  return *this;
}

AsnLen
ROSEResult::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (result))
  {
    l = result->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;
  }

    l = invokeID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  if (NOT_NULL (sessionID))
  {
    l = sessionID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // ROSEResult::BEncContent


void ROSEResult::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEResult::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 1))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
       && (tag1 != MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  sessionID = new UTF8String;
    sessionID->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    invokeID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  result = new ROSEResultSeq;
    result->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEResult::BDecContent

AsnLen ROSEResult::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEResult::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  if (NOT_NULL (sessionID))
  {
    sessionID->JEnc (tmp);
    b["sessionID"] = tmp;
  }

    invokeID.JEnc (tmp);
    b["invokeID"] = tmp;

  if (NOT_NULL (result))
  {
    result->JEnc (tmp);
    b["result"] = tmp;
  }

}


void ROSEResult::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEResult::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEResult::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("sessionID")) {
     delete sessionID;
    sessionID = new UTF8String;
    if (!sessionID->JDec(b["sessionID"])) throw InvalidTagException(typeName(), "decode failed: sessionID", STACK_ENTRY);
  }
  if (b.isMember("invokeID")) {
    if (!invokeID.JDec(b["invokeID"])) throw InvalidTagException(typeName(), "decode failed: invokeID", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: invokeID", STACK_ENTRY);
  if (b.isMember("result")) {
     delete result;
    result = new ROSEResultSeq;
    if (!result->JDec(b["result"])) throw InvalidTagException(typeName(), "decode failed: result", STACK_ENTRY);
  }
  return true;
} // ROSEResult::JDec

void ROSEResult::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	if (NOT_NULL (sessionID))
	{
		Indent(os, indent);
		os << "sessionID ";
		sessionID->Print(os, indent);
		os << std::endl;
	}

	Indent(os, indent);
	os << "invokeID ";
	invokeID.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (result))
	{
		Indent(os, indent);
		os << "result ";
		result->Print(os, indent);
		os << std::endl;
	}

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEResult::Print()

void ROSEResult::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
  if (NOT_NULL (sessionID))
  {
    sessionID->PrintXML(os, "sessionID");
  }

    invokeID.PrintXML(os, "invokeID");

  if (NOT_NULL (result))
  {
    result->PrintXML(os, "result");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEResult::PrintXML


RejectProblem::RejectProblem(const RejectProblem &that)
{
   Init();
   *this = that;
}
void RejectProblem::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = generalProblemCid;
  generalProblem = NULL;
}


int RejectProblem::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (generalProblem != NULL)
		generalProblem->checkConstraints(pConstraintFails);

	if (invokeProblem != NULL)
		invokeProblem->checkConstraints(pConstraintFails);

	if (returnResultProblem != NULL)
		returnResultProblem->checkConstraints(pConstraintFails);

	if (returnErrorProblem != NULL)
		returnErrorProblem->checkConstraints(pConstraintFails);

	return 0;
}


void RejectProblem::Clear()
{
  switch (choiceId)
  {
    case generalProblemCid:
      delete generalProblem;
      generalProblem = NULL;
      break;
    case invokeProblemCid:
      delete invokeProblem;
      invokeProblem = NULL;
      break;
    case returnResultProblemCid:
      delete returnResultProblem;
      returnResultProblem = NULL;
      break;
    case returnErrorProblemCid:
      delete returnErrorProblem;
      returnErrorProblem = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *RejectProblem::Clone() const
{
  return new RejectProblem(*this);
}

RejectProblem &RejectProblem::operator = (const RejectProblem &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.generalProblem != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case generalProblemCid:
           generalProblem = new GeneralProblem(*that.generalProblem);
           break;
         case invokeProblemCid:
           invokeProblem = new InvokeProblem(*that.invokeProblem);
           break;
         case returnResultProblemCid:
           returnResultProblem = new ReturnResultProblem(*that.returnResultProblem);
           break;
         case returnErrorProblemCid:
           returnErrorProblem = new ReturnErrorProblem(*that.returnErrorProblem);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
RejectProblem::BEncContent (AsnBuf &_b) const
{
    FUNC("RejectProblem::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case generalProblemCid:
      l = generalProblem->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
      break;

    case invokeProblemCid:
      l = invokeProblem->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
      break;

    case returnResultProblemCid:
      l = returnResultProblem->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
      break;

    case returnErrorProblemCid:
      l = returnErrorProblem->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // RejectProblem::BEncContent


void RejectProblem::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("RejectProblem::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 0):
      choiceId = generalProblemCid;
        generalProblem = new GeneralProblem;
        generalProblem->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 1):
      choiceId = invokeProblemCid;
        invokeProblem = new InvokeProblem;
        invokeProblem->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
      choiceId = returnResultProblemCid;
        returnResultProblem = new ReturnResultProblem;
        returnResultProblem->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 3):
      choiceId = returnErrorProblemCid;
        returnErrorProblem = new ReturnErrorProblem;
        returnErrorProblem->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // RejectProblem::BDecContent


AsnLen RejectProblem::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void RejectProblem::JEnc (EJson::Value &b) const
{
   FUNC("RejectProblem::JEnc()");
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  switch (choiceId)
  {
    case generalProblemCid:
    generalProblem->JEnc (tmp);
    b["generalProblem"] = tmp;
      break;

    case invokeProblemCid:
    invokeProblem->JEnc (tmp);
    b["invokeProblem"] = tmp;
      break;

    case returnResultProblemCid:
    returnResultProblem->JEnc (tmp);
    b["returnResultProblem"] = tmp;
      break;

    case returnErrorProblemCid:
    returnErrorProblem->JEnc (tmp);
    b["returnErrorProblem"] = tmp;
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
} // RejectProblem::JEnc


void RejectProblem::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

bool RejectProblem::JDec (const EJson::Value &b){
   FUNC("RejectProblem::JDec()");
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("generalProblem")) {
    choiceId = generalProblemCid;
    delete generalProblem;
    generalProblem = new GeneralProblem;
    if (!generalProblem->JDec(b["generalProblem"])) throw InvalidTagException(typeName(), "decode failed: generalProblem", STACK_ENTRY);
  }
  else if (b.isMember("invokeProblem")) {
    choiceId = invokeProblemCid;
    delete invokeProblem;
    invokeProblem = new InvokeProblem;
    if (!invokeProblem->JDec(b["invokeProblem"])) throw InvalidTagException(typeName(), "decode failed: invokeProblem", STACK_ENTRY);
  }
  else if (b.isMember("returnResultProblem")) {
    choiceId = returnResultProblemCid;
    delete returnResultProblem;
    returnResultProblem = new ReturnResultProblem;
    if (!returnResultProblem->JDec(b["returnResultProblem"])) throw InvalidTagException(typeName(), "decode failed: returnResultProblem", STACK_ENTRY);
  }
  else if (b.isMember("returnErrorProblem")) {
    choiceId = returnErrorProblemCid;
    delete returnErrorProblem;
    returnErrorProblem = new ReturnErrorProblem;
    if (!returnErrorProblem->JDec(b["returnErrorProblem"])) throw InvalidTagException(typeName(), "decode failed: returnErrorProblem", STACK_ENTRY);
  }
  else
     throw InvalidTagException(typeName(), "no valid choice member", STACK_ENTRY);
  return true;
} // RejectProblem::JDec


void RejectProblem::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case generalProblemCid:
		os << "generalProblem ";
		if (generalProblem)
			generalProblem->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case invokeProblemCid:
		os << "invokeProblem ";
		if (invokeProblem)
			invokeProblem->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case returnResultProblemCid:
		os << "returnResultProblem ";
		if (returnResultProblem)
			returnResultProblem->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case returnErrorProblemCid:
		os << "returnErrorProblem ";
		if (returnErrorProblem)
			returnErrorProblem->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of RejectProblem::Print()

void RejectProblem::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"RejectProblem\" type=\"CHOICE\">";
  }
  else
        os << "<RejectProblem type=\"CHOICE\">";
  switch (choiceId)
  {
    case generalProblemCid:
      if (generalProblem)
        generalProblem->PrintXML(os,"generalProblem");
      else
      {
        os << "<generalProblem -- void3 -- /generalProblem>" << std::endl;
      }
      break;

    case invokeProblemCid:
      if (invokeProblem)
        invokeProblem->PrintXML(os,"invokeProblem");
      else
      {
        os << "<invokeProblem -- void3 -- /invokeProblem>" << std::endl;
      }
      break;

    case returnResultProblemCid:
      if (returnResultProblem)
        returnResultProblem->PrintXML(os,"returnResultProblem");
      else
      {
        os << "<returnResultProblem -- void3 -- /returnResultProblem>" << std::endl;
      }
      break;

    case returnErrorProblemCid:
      if (returnErrorProblem)
        returnErrorProblem->PrintXML(os,"returnErrorProblem");
      else
      {
        os << "<returnErrorProblem -- void3 -- /returnErrorProblem>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</RejectProblem>";
} // RejectProblem::PrintXML

void ROSEReject::Init(void)
{
  sessionID = NULL;
  reject = NULL;
  details = NULL;
  authentication = NULL;
}


int ROSEReject::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (sessionID != NULL)
		sessionID->checkConstraints(pConstraintFails);

	invokedID.checkConstraints(pConstraintFails);

	if (reject != NULL)
		reject->checkConstraints(pConstraintFails);

	if (details != NULL)
		details->checkConstraints(pConstraintFails);

	if (authentication != NULL)
		authentication->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEReject::Clear()
{
  if(sessionID)
    delete sessionID;
  sessionID = NULL;
  invokedID.Clear();
  if(reject)
    delete reject;
  reject = NULL;
  if(details)
    delete details;
  details = NULL;
  if(authentication)
    delete authentication;
  authentication = NULL;
}

ROSEReject::ROSEReject(const ROSEReject &that)
{
   Init();
   *this = that;
}
AsnType *ROSEReject::Clone() const
{
  return new ROSEReject(*this);
}

ROSEReject &ROSEReject::operator = (const ROSEReject &that)
{
  if (this != &that)
  {
    Clear();
    if (that.sessionID)
    {
      if (!sessionID)
        sessionID = new UTF8String;
      *sessionID = *that.sessionID;
    }
    else
    {
      delete sessionID;
      sessionID = NULL;
    }
    invokedID = that.invokedID;
    if (that.reject)
    {
      if (!reject)
        reject = new RejectProblem;
      *reject = *that.reject;
    }
    else
    {
      delete reject;
      reject = NULL;
    }
    if (that.details)
    {
      if (!details)
        details = new UTF8String;
      *details = *that.details;
    }
    else
    {
      delete details;
      details = NULL;
    }
    if (that.authentication)
    {
      if (!authentication)
        authentication = new ROSEAuthResult;
      *authentication = *that.authentication;
    }
    else
    {
      delete authentication;
      authentication = NULL;
    }
  }

  return *this;
}

AsnLen
ROSEReject::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (authentication))
  {
    l = authentication->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (details))
  {
    l = details->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    totalLen += l;
  }

  if (NOT_NULL (reject))
  {
    l = reject->BEncContent (_b);
    totalLen += l;
  }

    l = invokedID.BEncContent (_b);
    totalLen += l;

  if (NOT_NULL (sessionID))
  {
    l = sessionID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;
  }

  return totalLen;
} // ROSEReject::BEncContent


void ROSEReject::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ROSEReject::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  if (elmtLen0 == 0)
    return;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 1))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
       && (tag1 != MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  sessionID = new UTF8String;
    sessionID->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if (tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)
    || tag1 == MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    invokedID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if (tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)
    || tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)
    || tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)
    || tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  reject = new RejectProblem;
    reject->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  details = new UTF8String;
    details->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if (tag1 == MAKE_TAG_ID (CNTX, CONS, 4))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  authentication = new ROSEAuthResult;
    authentication->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

  }

  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
  {
    // nothing more to read, just add the bytes read previously
    bytesDecoded += seqBytesDecoded;
  }
} // ROSEReject::BDecContent

AsnLen ROSEReject::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ROSEReject::JEnc (EJson::Value &b) const
{
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  if (NOT_NULL (sessionID))
  {
    sessionID->JEnc (tmp);
    b["sessionID"] = tmp;
  }

    invokedID.JEnc (tmp);
    b["invokedID"] = tmp;

  if (NOT_NULL (reject))
  {
    reject->JEnc (tmp);
    b["reject"] = tmp;
  }

  if (NOT_NULL (details))
  {
    details->JEnc (tmp);
    b["details"] = tmp;
  }

  if (NOT_NULL (authentication))
  {
    authentication->JEnc (tmp);
    b["authentication"] = tmp;
  }

}


void ROSEReject::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ROSEReject::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

bool ROSEReject::JDec (const EJson::Value &b){
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("sessionID")) {
     delete sessionID;
    sessionID = new UTF8String;
    if (!sessionID->JDec(b["sessionID"])) throw InvalidTagException(typeName(), "decode failed: sessionID", STACK_ENTRY);
  }
  if (b.isMember("invokedID")) {
    if (!invokedID.JDec(b["invokedID"])) throw InvalidTagException(typeName(), "decode failed: invokedID", STACK_ENTRY);
  }
  else throw InvalidTagException(typeName(), "not found: invokedID", STACK_ENTRY);
  if (b.isMember("reject")) {
     delete reject;
    reject = new RejectProblem;
    if (!reject->JDec(b["reject"])) throw InvalidTagException(typeName(), "decode failed: reject", STACK_ENTRY);
  }
  if (b.isMember("details")) {
     delete details;
    details = new UTF8String;
    if (!details->JDec(b["details"])) throw InvalidTagException(typeName(), "decode failed: details", STACK_ENTRY);
  }
  if (b.isMember("authentication")) {
     delete authentication;
    authentication = new ROSEAuthResult;
    if (!authentication->JDec(b["authentication"])) throw InvalidTagException(typeName(), "decode failed: authentication", STACK_ENTRY);
  }
  return true;
} // ROSEReject::JDec

void ROSEReject::Print(std::ostream& os, unsigned short indent) const
{
	os << std::endl;
	Indent(os, indent);
	os << "{ -- SEQUENCE --" << std::endl;
	++indent;

	if (NOT_NULL (sessionID))
	{
		Indent(os, indent);
		os << "sessionID ";
		sessionID->Print(os, indent);
		os << std::endl;
	}

	Indent(os, indent);
	os << "invokedID ";
	invokedID.Print(os, indent);
	os << std::endl;

	if (NOT_NULL (reject))
	{
		Indent(os, indent);
		os << "reject ";
		reject->Print(os, indent);
		os << std::endl;
	}

	if (NOT_NULL (details))
	{
		Indent(os, indent);
		os << "details ";
		details->Print(os, indent);
		os << std::endl;
	}

	if (NOT_NULL (authentication))
	{
		Indent(os, indent);
		os << "authentication ";
		authentication->Print(os, indent);
		os << std::endl;
	}

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ROSEReject::Print()

void ROSEReject::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
  if (NOT_NULL (sessionID))
  {
    sessionID->PrintXML(os, "sessionID");
  }

    invokedID.PrintXML(os, "invokedID");

  if (NOT_NULL (reject))
  {
    reject->PrintXML(os, "reject");
  }

  if (NOT_NULL (details))
  {
    details->PrintXML(os, "details");
  }

  if (NOT_NULL (authentication))
  {
    authentication->PrintXML(os, "authentication");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ROSEReject::PrintXML


ROSEMessage::ROSEMessage(const ROSEMessage &that)
{
   Init();
   *this = that;
}
void ROSEMessage::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = invokeCid;
  invoke = NULL;
}


int ROSEMessage::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (invoke != NULL)
		invoke->checkConstraints(pConstraintFails);

	if (result != NULL)
		result->checkConstraints(pConstraintFails);

	if (error != NULL)
		error->checkConstraints(pConstraintFails);

	if (reject != NULL)
		reject->checkConstraints(pConstraintFails);

	return 0;
}


void ROSEMessage::Clear()
{
  switch (choiceId)
  {
    case invokeCid:
      delete invoke;
      invoke = NULL;
      break;
    case resultCid:
      delete result;
      result = NULL;
      break;
    case errorCid:
      delete error;
      error = NULL;
      break;
    case rejectCid:
      delete reject;
      reject = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *ROSEMessage::Clone() const
{
  return new ROSEMessage(*this);
}

ROSEMessage &ROSEMessage::operator = (const ROSEMessage &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.invoke != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case invokeCid:
           invoke = new ROSEInvoke(*that.invoke);
           break;
         case resultCid:
           result = new ROSEResult(*that.result);
           break;
         case errorCid:
           error = new ROSEError(*that.error);
           break;
         case rejectCid:
           reject = new ROSEReject(*that.reject);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
ROSEMessage::BEncContent (AsnBuf &_b) const
{
    FUNC("ROSEMessage::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case invokeCid:
      l = invoke->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
      break;

    case resultCid:
      l = result->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
      break;

    case errorCid:
      l = error->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
      break;

    case rejectCid:
      l = reject->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // ROSEMessage::BEncContent


void ROSEMessage::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("ROSEMessage::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = invokeCid;
        invoke = new ROSEInvoke;
        invoke->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = resultCid;
        result = new ROSEResult;
        result->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = errorCid;
        error = new ROSEError;
        error->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 4):
      choiceId = rejectCid;
        reject = new ROSEReject;
        reject->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // ROSEMessage::BDecContent


AsnLen ROSEMessage::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void ROSEMessage::JEnc (EJson::Value &b) const
{
   FUNC("ROSEMessage::JEnc()");
  b = EJson::Value(EJson::objectValue);

  EJson::Value tmp;

  switch (choiceId)
  {
    case invokeCid:
    invoke->JEnc (tmp);
    b["invoke"] = tmp;
      break;

    case resultCid:
    result->JEnc (tmp);
    b["result"] = tmp;
      break;

    case errorCid:
    error->JEnc (tmp);
    b["error"] = tmp;
      break;

    case rejectCid:
    reject->JEnc (tmp);
    b["reject"] = tmp;
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
} // ROSEMessage::JEnc


void ROSEMessage::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

bool ROSEMessage::JDec (const EJson::Value &b){
   FUNC("ROSEMessage::JDec()");
  Clear();
  if (!b.isObject()) return false;

  EJson::Value tmp;
  if (b.isMember("invoke")) {
    choiceId = invokeCid;
    delete invoke;
    invoke = new ROSEInvoke;
    if (!invoke->JDec(b["invoke"])) throw InvalidTagException(typeName(), "decode failed: invoke", STACK_ENTRY);
  }
  else if (b.isMember("result")) {
    choiceId = resultCid;
    delete result;
    result = new ROSEResult;
    if (!result->JDec(b["result"])) throw InvalidTagException(typeName(), "decode failed: result", STACK_ENTRY);
  }
  else if (b.isMember("error")) {
    choiceId = errorCid;
    delete error;
    error = new ROSEError;
    if (!error->JDec(b["error"])) throw InvalidTagException(typeName(), "decode failed: error", STACK_ENTRY);
  }
  else if (b.isMember("reject")) {
    choiceId = rejectCid;
    delete reject;
    reject = new ROSEReject;
    if (!reject->JDec(b["reject"])) throw InvalidTagException(typeName(), "decode failed: reject", STACK_ENTRY);
  }
  else
     throw InvalidTagException(typeName(), "no valid choice member", STACK_ENTRY);
  return true;
} // ROSEMessage::JDec


void ROSEMessage::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case invokeCid:
		os << "invoke ";
		if (invoke)
			invoke->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case resultCid:
		os << "result ";
		if (result)
			result->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case errorCid:
		os << "error ";
		if (error)
			error->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case rejectCid:
		os << "reject ";
		if (reject)
			reject->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of ROSEMessage::Print()

void ROSEMessage::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"ROSEMessage\" type=\"CHOICE\">";
  }
  else
        os << "<ROSEMessage type=\"CHOICE\">";
  switch (choiceId)
  {
    case invokeCid:
      if (invoke)
        invoke->PrintXML(os,"invoke");
      else
      {
        os << "<invoke -- void3 -- /invoke>" << std::endl;
      }
      break;

    case resultCid:
      if (result)
        result->PrintXML(os,"result");
      else
      {
        os << "<result -- void3 -- /result>" << std::endl;
      }
      break;

    case errorCid:
      if (error)
        error->PrintXML(os,"error");
      else
      {
        os << "<error -- void3 -- /error>" << std::endl;
      }
      break;

    case rejectCid:
      if (reject)
        reject->PrintXML(os,"reject");
      else
      {
        os << "<reject -- void3 -- /reject>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</ROSEMessage>";
} // ROSEMessage::PrintXML

#ifndef NO_NAMESPACE
} // namespace close
#endif
