#ifndef _asn_chartraits_h
#define _asn_chartraits_h 1

#include <cstring> // For memmove, memset, memchr
// #include <bits/fpos.h> 		// For streampos
#include <ios>

namespace std
{
	/// char_traits unsigned char specialization
	template <> struct char_traits<unsigned char>
	{
		typedef unsigned char char_type;
		typedef int int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef mbstate_t state_type;

		static void assign(char_type& __c1, const char_type& __c2)
		{
			__c1 = __c2;
		}

		static bool eq(const char_type& __c1, const char_type& __c2)
		{
			return __c1 == __c2;
		}

		static bool lt(const char_type& __c1, const char_type& __c2)
		{
			return __c1 < __c2;
		}

		static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
		{
			return memcmp(__s1, __s2, __n);
		}

		static size_t length(const char_type* __s)
		{
			return strlen((char*)__s);
		}

		static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
		{
			return static_cast<const char_type*>(memchr(__s, __a, __n));
		}

		static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
		{
			return static_cast<char_type*>(memmove(__s1, __s2, __n));
		}

		static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
		{
			return static_cast<char_type*>(memcpy(__s1, __s2, __n));
		}

		static char_type* assign(char_type* __s, size_t __n, char_type __a)
		{
			return static_cast<char_type*>(memset(__s, __a, __n));
		}

		static char_type to_char_type(const int_type& __c)
		{
			return static_cast<char_type>(__c);
		}

		// To keep both the byte 0xff and the eof symbol 0xffffffff
		// from ending up as 0xffffffff.
		static int_type to_int_type(const char_type& __c)
		{
			return static_cast<int_type>(__c);
		}

		static bool eq_int_type(const int_type& __c1, const int_type& __c2)
		{
			return __c1 == __c2;
		}

		static int_type eof()
		{
			return static_cast<int_type>(EOF);
		}

		static int_type not_eof(const int_type& __c)
		{
			return (__c == eof()) ? 0 : __c;
		}
	};

#if defined(HPUX) || defined(HPUX32) || defined(SCO_SV)

	// wchar specialization for HP-UX
	template <> struct char_traits<wchar_t>
	{
		typedef wchar_t char_type;
		typedef wint_t int_type;
		typedef streamoff off_type;
		typedef streampos pos_type;
		typedef mbstate_t state_type;

		static void assign(char_type& __c1, const char_type& __c2)
		{
			__c1 = __c2;
		}

		static bool eq(const char_type& __c1, const char_type& __c2)
		{
			return __c1 == __c2;
		}

		static bool lt(const char_type& __c1, const char_type& __c2)
		{
			return __c1 < __c2;
		}

		static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
		{
			return wcsncmp(__s1, __s2, __n);
		}

		static size_t length(const char_type* __s)
		{
			return wcslen(__s);
		}

		static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
		{
			char_type* tmp_wcs = wcschr(__s, __a);
			if (tmp_wcs == NULL)
				return NULL;

			if (__n > 0 && wcslen(tmp_wcs) > __n)
				return NULL;

			return tmp_wcs;
		}

		static char_type* move(char_type* __s1, const char_type* __s2, int_type __n)
		{
			return (char_type*)memmove((void*)__s1, (void*)__s2, __n * sizeof(char_type));
		}

		static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
		{
			return wcsncpy(__s1, __s2, __n);
		}

		static char_type* assign(char_type* __s, size_t __n, char_type __a)
		{
			return (char_type*)memset((char*)__s, __a, sizeof(char_type) * __n);
		}

		static char_type to_char_type(const int_type& __c)
		{
			return char_type(__c);
		}

		static int_type to_int_type(const char_type& __c)
		{
			return int_type(__c);
		}

		static bool eq_int_type(const int_type& __c1, const int_type& __c2)
		{
			return __c1 == __c2;
		}

		static int_type eof()
		{
			return static_cast<int_type>(WEOF);
		}

		static int_type not_eof(const int_type& __c)
		{
			return eq_int_type(__c, eof()) ? 0 : __c;
		}
	};

#elif defined(SunOS)

	// wchar_t specialization
	template <> struct char_traits<wchar_t>
	{
		typedef wchar_t char_type;
		typedef wint_t int_type;
		typedef streamoff off_type;
		typedef streampos pos_type;
		typedef mbstate_t state_type;

		static void assign(char_type& __c1, const char_type& __c2)
		{
			__c1 = __c2;
		}

		static bool eq(const char_type& __c1, const char_type& __c2)
		{
			return __c1 == __c2;
		}

		static bool lt(const char_type& __c1, const char_type& __c2)
		{
			return __c1 < __c2;
		}

		static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
		{
			return wmemcmp(__s1, __s2, __n);
		}

		static size_t length(const char_type* __s)
		{
			return wcslen(__s);
		}

		static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
		{
			return wmemchr(__s, __a, __n);
		}

		static char_type* move(char_type* __s1, const char_type* __s2, int_type __n)
		{
			return wmemmove(__s1, __s2, __n);
		}

		static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
		{
			return wmemcpy(__s1, __s2, __n);
		}

		static char_type* assign(char_type* __s, size_t __n, char_type __a)
		{
			return wmemset(__s, __a, __n);
		}

		static char_type to_char_type(const int_type& __c)
		{
			return char_type(__c);
		}

		static int_type to_int_type(const char_type& __c)
		{
			return int_type(__c);
		}

		static bool eq_int_type(const int_type& __c1, const int_type& __c2)
		{
			return __c1 == __c2;
		}

		static int_type eof()
		{
			return static_cast<int_type>(WEOF);
		}

		static int_type not_eof(const int_type& __c)
		{
			return eq_int_type(__c, eof()) ? 0 : __c;
		}
	};
#endif //  HP-UX or SunOS

} // namespace std

#endif // _asn_chartraits_h
